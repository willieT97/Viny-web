<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Viny Map – Enhanced Visibility</title>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-W45MGJ0PLH"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-W45MGJ0PLH');
  </script>
    
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    #map {
      height: calc(100vh - 60px);
      width: 100%;
    }

    .leaflet-tile {
      filter: brightness(0.9) contrast(1.1);
    }

    .marker-icon {
      width: 32px;
      height: 32px;
      filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.6));
    }

    footer {
      height: 60px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      font-size: 14px;
    }

    .footer-links {
      margin-top: 4px;
      margin-bottom: 1rem;
    }

    .footer-links a {
      color: #fff;
      margin: 10px 10px;
      text-decoration: none;
    }

    .footer-links a:hover {
      text-decoration: underline;
    }


    #filter-control {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 14px;
      border-radius: 8px;
      color: white;
      font-family: sans-serif;
      font-size: 14px;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #filter-control select {
      padding: 2px 6px;
      border-radius: 4px;
      border: none;
    }
  </style>
</head>
<body>

  <div id="filter-control">
    <label for="time-filter">Time:</label>
    <select id="time-filter">
      <option value="1">Next Day</option>
      <option value="7" selected>Next Week</option>
      <option value="30">Next Month</option>
      <option value="365">Next Year</option>
    </select>

    <label for="type-filter">Type:</label>
    <select id="type-filter">
      <option value="all" selected>All</option>
      <option value="open">Open Session</option>
      <option value="closed">Closed Session</option>
      <option value="gig">Gig</option>
    </select>
  </div>

  <button id="open-news">News</button>

  <div id="news-sidebar">
    <button id="close-news">×</button>
    <h2>Latest News</h2>
    <div id="news-feed">
    <div class="news-container"></div>
      <!-- News items will go here -->
    </div>
  </div>



  <div id="map"></div>

  <!-- JS LIBRARIES -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

   <style> 
     /* Sidebar */
#news-sidebar {
  position: fixed;
  top: 0;
  left: -400px; /* Hidden by default */
  width: 300px;
  height: 100%;
  background: rgba(0, 0, 0, 0.9);
  color: #fff;
  transition: left 0.3s ease;
  z-index: 1000;
  padding: 20px;
}

#news-sidebar.open {
  left: 0;
}

#news-sidebar h2 {
  text-align: center;
  margin-top: 8px; /* optional: adds space below the close button */
}

#close-news {
  position: absolute;
  top: 10px;
  right: 10px;
  background: transparent;
  color: #fff;
  font-size: 36px;
  border: none;
  cursor: pointer;
}

/* News button */
#open-news {
  position: fixed;
  top: 20px;
  left: 3rem;
  z-index: 1100;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  padding: 10px 16px;
  border-radius: 6px;
  border: none;
  cursor: pointer;
  transition: left 0.3s ease;
}

#open-news:hover {
  background: #ff2727;
}


#open-news.shifted {
  left: 320px; /* matches sidebar width */
}

.news-container {
  padding: 1rem;
  overflow-y: auto;
  max-height: 100vh; /* so it scrolls if too long */
}

.news-item {
  background: #1e1e1e; /* dark card look */
  color: #fff;
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.news-item:nth-child(odd) {
  background: #2a2a2a; /* alternating backgrounds */
}

.news-item:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.news-item h3 {
  font-family: 'Bowlby One SC', sans-serif;
  font-size: 1.2rem;
  margin: 0 0 0.5rem;
  color: #ff2727; /* highlight your main color */
}

.news-item small {
  color: #bbb;
  font-size: 0.85rem;
}

.news-item p {
  margin: 0.25rem 0;
  line-height: 1.4;
}

  </style>

  <script>
    const map = L.map('map').setView([53.0331, -7.2996], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    function createDivIcon(imagePath) {
      return L.divIcon({
        html: `<img src="${imagePath}" class="marker-icon"/>`,
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32],
        className: ''
      });
    }

    const openIcon = createDivIcon('images/open-session.png');
    const closedIcon = createDivIcon('images/closed-session.png');
    const gigIcon = createDivIcon('images/gig.png');
    const venueIcon = createDivIcon('images/venue.png'); // your stock pin for venues with multiple events

    const markers = L.markerClusterGroup();
    let heatLayer = null;

    const sheetURL = 'https://api.sheetbest.com/sheets/1c3ecc0a-2eb8-4b82-b1e4-b5cdb51f4bc7';
    const apiKey = '1bce004158a94773afe52570c225384a';

    function parseSheetDate(dateStr) {
      dateStr = dateStr.trim();
      let parts, year, month, day;
      if (dateStr.includes('-')) {
        [year, month, day] = dateStr.split('-');
      } else if (dateStr.includes('/')) {
        [month, day, year] = dateStr.split('/');
      } else {
        return new Date('invalid');
      }
      return new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T00:00:00`);
    }

    function getFilterRangeDays() {
      return parseInt(document.getElementById('time-filter').value, 10);
    }

    function getTypeFilter() {
      return document.getElementById('type-filter').value.toLowerCase();
    }

    // Store event coords for heatmap points
    let heatPoints = [];

    function loadMarkers() {
      markers.clearLayers();
      heatPoints = [];

      fetch(sheetURL)
        .then(response => {
          if (!response.ok) throw new Error(`Sheet fetch error: ${response.status}`);
          return response.json();
        })
        .then(async data => {
          // We'll group events by venue latlng string "lat,lng"
          const venueEventsMap = new Map();

          const now = new Date();
          now.setHours(0, 0, 0, 0);
          const filterDays = getFilterRangeDays();
          const futureDate = new Date(now.getTime() + filterDays * 24 * 60 * 60 * 1000);
          const typeFilter = getTypeFilter();

          // Helper to geocode once per unique eircode
          const eircodeCache = new Map();

          async function geocode(eircode) {
            if (eircodeCache.has(eircode)) return eircodeCache.get(eircode);
            try {
              const res = await fetch(`https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(eircode)}&key=${apiKey}`);
              const geoData = await res.json();
              if (geoData.results.length) {
                const coords = geoData.results[0].geometry;
                eircodeCache.set(eircode, coords);
                return coords;
              }
            } catch(e) {
              console.error(`Geocode error for ${eircode}:`, e);
            }
            eircodeCache.set(eircode, null);
            return null;
          }

          // Process events one by one
          for (const [i, row] of data.entries()) {
            const name    = row.Name || 'Unnamed';
            const type    = (row.Type || '').trim();
            const dateRaw = (row.Date || '').trim();
            const eircode = (row.Eircode || '').trim();
            const venue   = (row.Venue || '').trim();
            const time    = (row.Time || '').trim();

            if (!dateRaw || !eircode) continue;

            const eventDate = parseSheetDate(dateRaw);
            if (isNaN(eventDate) || eventDate < now || eventDate > futureDate) continue;

            const typeLower = type.toLowerCase();
            if (typeFilter !== 'all' && !typeLower.includes(typeFilter)) continue;

            const coords = await geocode(eircode);
            if (!coords) continue;

            const latlngKey = `${coords.lat.toFixed(6)},${coords.lng.toFixed(6)}`;

            if (!venueEventsMap.has(latlngKey)) venueEventsMap.set(latlngKey, []);
            venueEventsMap.get(latlngKey).push({
              name, type, dateRaw, time, venue, lat: coords.lat, lng: coords.lng
            });
          }

          // Now create markers and heat points
          venueEventsMap.forEach((events, latlngKey) => {
            const lat = events[0].lat;
            const lng = events[0].lng;

            // Add to heatPoints (with optional intensity)
            heatPoints.push([lat, lng, events.length]);

            if (events.length === 1) {
              // Single event - show event marker with correct icon
              const ev = events[0];
              let chosenIcon = gigIcon;
              const typeLower = ev.type.toLowerCase();
              if (typeLower.includes('open'))      chosenIcon = openIcon;
              else if (typeLower.includes('closed')) chosenIcon = closedIcon;

              const popupHtml = `
                <strong>${ev.name}</strong><br>
                Type: ${ev.type}<br>
                Date: ${ev.dateRaw}<br>
                Time: ${ev.time}<br>
                Venue: <em>${ev.venue || 'Unknown venue'}</em><br>
                <a href="https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}" target="_blank">Get Directions</a>
              `;

              const marker = L.marker([lat, lng], { icon: chosenIcon }).bindPopup(popupHtml);
              markers.addLayer(marker);
            } else {
              // Multiple events at one venue - use venueIcon with list popup
              const popupHtml = `<div style="font-size:18px; font-weight:bold; margin-bottom:8px;">${events[0].venue || 'Multiple Events'}</div><ul style="padding-left:18px; margin:0;">` +
                events.map(ev => 
                  `<li><strong>${ev.name}</strong><br>
                    Type: (${ev.type})<br>
                    Date: ${ev.dateRaw}<br>
                    Time:${ev.time ? 'at ' + ev.time : ''}</li>`
                ).join('') +
                `</ul><a href="https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}" target="_blank">Get Directions</a>`;

              const marker = L.marker([lat, lng], { icon: venueIcon }).bindPopup(popupHtml);
              markers.addLayer(marker);
            }
          });

          // Add markers layer to map if zoom >= 11
          if (map.getZoom() >= 11) {
            if (!map.hasLayer(markers)) map.addLayer(markers);
          }

          // Remove existing heat layer and create a new one
          if (heatLayer) map.removeLayer(heatLayer);
          heatLayer = L.heatLayer(heatPoints, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            max: 10 // max intensity for scaling color
          });

          // Add heat layer if zoom < 11
          if (map.getZoom() < 11) {
            if (!map.hasLayer(heatLayer)) map.addLayer(heatLayer);
          }
        })
        .catch(err => console.error('Fetch or parse error:', err));
    }

    // Switch between markers and heatmap based on zoom level
    function updateLayerVisibility() {
      if (map.getZoom() < 11) {
        if (map.hasLayer(markers)) map.removeLayer(markers);
        if (heatLayer && !map.hasLayer(heatLayer)) map.addLayer(heatLayer);
      } else {
        if (heatLayer && map.hasLayer(heatLayer)) map.removeLayer(heatLayer);
        if (!map.hasLayer(markers)) map.addLayer(markers);
      }
    }

    map.on('zoomend', updateLayerVisibility);

    document.getElementById('time-filter').addEventListener('change', () => {
      loadMarkers();
    });
    document.getElementById('type-filter').addEventListener('change', () => {
      loadMarkers();
    });

    loadMarkers();

 const openNewsBtn = document.getElementById('open-news');
const closeNewsBtn = document.getElementById('close-news');
const newsSidebar = document.getElementById('news-sidebar');

openNewsBtn.addEventListener('click', () => {
  newsSidebar.classList.add('open');
  openNewsBtn.classList.add('shifted');
});

closeNewsBtn.addEventListener('click', () => {
  newsSidebar.classList.remove('open');
  openNewsBtn.classList.remove('shifted');
});


// Fetch News Feed (using same logic as map)
fetch(sheetURL)
  .then(response => response.json())
  .then(data => {
    const container = document.querySelector('.news-container');

    const now = new Date();
    now.setHours(0, 0, 0, 0);
    const filterDays = getFilterRangeDays(); // reuse the map’s filter dropdown
    const futureDate = new Date(now.getTime() + filterDays * 24 * 60 * 60 * 1000);
    const typeFilter = getTypeFilter(); // reuse type filter

    const validEvents = [];

    for (const row of data) {
      const name    = row.Name || 'Unnamed';
      const type    = (row.Type || '').trim();
      const dateRaw = (row.Date || '').trim();
      const venue   = (row.Venue || '').trim();
      const time    = (row.Time || '').trim();

      if (!dateRaw) continue;

      const eventDate = parseSheetDate(dateRaw);
      if (isNaN(eventDate) || eventDate < now || eventDate > futureDate) continue;

      const typeLower = type.toLowerCase();
      if (typeFilter !== 'all' && !typeLower.includes(typeFilter)) continue;

      validEvents.push({ name, type, dateRaw, time, venue, eventDate });
    }

    // Sort newest first
    validEvents.sort((a, b) => a.eventDate - b.eventDate);

    // Build feed
    validEvents.forEach(ev => {
      const div = document.createElement('div');
      div.className = 'news-item';
      div.innerHTML = `
        <h3>${ev.name}</h3>
        <p><small>${ev.dateRaw}${ev.time ? ' at ' + ev.time : ''}</small></p>
        <p>${ev.venue}</p>
      `;
      container.appendChild(div);
    });
  })
  .catch(err => console.error('Feed fetch error:', err));

  </script>

  <footer>
    <p>&copy; 2025 Viny. Connecting music lovers to music communities.</p>
    <div class="footer-links">
      <a href="map.html">Map</a>
      <a href="about.html">About</a>
      <a href="contact.html">Contact</a>
    </div>
  </footer>
</body>
</html>
